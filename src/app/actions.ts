
// src/app/actions.ts
'use server';

import { ProcessedEmail, EmailClassification, ClassificationCategory } from '@/lib/types';
import { zodToJsonSchema } from 'zod-to-json-schema';
import { batchClassificationSchema } from '@/lib/classifier';

// --- SERVER ACTION ---

const SYSTEM_PROMPT = `You are an expert AI Email Classifier...`; // Kept for when we switch back

export async function classifyEmailsAction(emails: ProcessedEmail[]): Promise<{ classifications?: EmailClassification[]; error?: string; }> {
    // =================================================================================
    // --- MOCK IMPLEMENTATION FOR UI DEVELOPMENT ---
    // This section is currently active to allow UI testing without a funded OpenAI key.
    // It simulates a successful API response with fake data.
    console.log('\n--- ⚠️ USING MOCK CLASSIFICATION DATA --- \nReturning simulated data for UI testing. Real API call is commented out.\n');
    
    // Simulate a network delay for realism
    await new Promise(resolve => setTimeout(resolve, 1000)); 

    const mockCategories: ClassificationCategory[] = ['Important', 'Promotional', 'Social', 'Marketing', 'Spam', 'General'];

    const mockClassifications: EmailClassification[] = emails.map((email, index) => ({
        id: email.id,
        // Cycle through the categories for variety
        category: mockCategories[index % mockCategories.length],
        summary: `This is a mock summary for the email titled "${email.subject}". The real summary would be generated by AI.`,
        actionable: index % 2 === 0, // Alternate between true and false
    }));

    return { classifications: mockClassifications };
    // =================================================================================

    /*
    // --- REAL IMPLEMENTATION (Currently Commented Out) ---
    // To enable, uncomment this block and remove or comment out the mock block above.
    const apiKey = process.env.OPENAI_API_KEY;

    if (!apiKey) {
      return { error: 'OpenAI API key is not configured on the server. Please ensure it is set in your .env.local file.' };
    }
    
    if (!emails.length) return { classifications: [] };

    const MAX_BATCH = 10;
    const workingEmails = emails.length > MAX_BATCH ? emails.slice(0, MAX_BATCH) : emails;
  
    const emailInputs = workingEmails.map(email => ({
      emailId: email.id,
      subject: email.subject,
      snippet: email.snippet,
      body_preview: email.bodyPreview,
    }));
  
    const prompt = `Classify the following emails: ${JSON.stringify(emailInputs, null, 2)}`;
    const jsonSchema = zodToJsonSchema(batchClassificationSchema, 'BatchClassificationSchema');
    
    const payload = {
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: SYSTEM_PROMPT },
        { role: 'user', content: `${prompt}\n\nSchema: ${JSON.stringify(jsonSchema)}` }
      ],
      temperature: 0.1,
    } as any;
  
    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`,
        },
        body: JSON.stringify(payload),
      });
  
      if (!response.ok) {
        const errText = await response.text().catch(() => 'Could not read error body');
        console.error('OpenAI API Error:', errText);
        if (response.status === 429 || errText?.toLowerCase().includes('quota')) {
          return { error: `OpenAI API Error: ${response.status} - Your OpenAI key may have insufficient quota or rate limits. Check your OpenAI plan, billing, and usage.` };
        }
        return { error: `OpenAI API Error: ${response.status} - ${errText}`};
      }

      const data = await response.json();
      const rawContent = data.choices?.[0]?.message?.content ?? '';

      let parsed: any = null;
      try {
        parsed = JSON.parse(rawContent);
      } catch (e) {
        const match = rawContent.match(/(\[\s*\{[\s\S]*\}\s*\])/m);
        if (match) {
          try { parsed = JSON.parse(match[0]); } catch (e2) { return { error: 'Failed to parse JSON from OpenAI response.' }; }
        } else {
            return { error: 'OpenAI returned non-JSON content.' };
        }
      }

      const validatedData = batchClassificationSchema.parse(parsed);

      const results: EmailClassification[] = validatedData.map(item => ({ id: item.emailId, ...item.classification }));
      
      if (emails.length > MAX_BATCH) {
        const mapById = new Map(results.map(r => [r.id, r]));
        const finalResults = emails.map(e => mapById.get(e.id) ?? ({ id: e.id, category: 'General', summary: 'Not classified (batch size limit)', actionable: false }));
        return { classifications: finalResults };
      }

      return { classifications: results };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
      return { error: `Classification failed: ${errorMessage}` };
    }
    */
}
